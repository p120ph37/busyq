#!/usr/bin/env bash
# gen-applet-table.sh — Generate applet_table.c from applets.def
#
# Reads the canonical applet registry and produces C source code for
# the busyq applet dispatch table.  Supports filtering by applet name
# or module to produce minimal custom builds.
#
# Usage:
#   gen-applet-table.sh [options]
#
# Options:
#   -d, --def FILE        Path to applets.def (default: src/applets.def)
#   -a, --applets LIST    Semicolon-separated applet names to include
#   -m, --modules LIST    Semicolon-separated module names to include
#   -o, --output FILE     Output file (default: stdout)
#   --list-modules        List modules needed for the selected applets
#   --list-applets        List all available applet names
#   -h, --help            Show this help
#
# If neither --applets nor --modules is given, all applets are included.
# The "core" module (busyq help) is always included.
#
# Examples:
#   # Generate full applet table (default build)
#   gen-applet-table.sh -o build/applet_table_gen.c
#
#   # Generate minimal table for a script that needs curl + ls + cat
#   gen-applet-table.sh --applets 'curl;ls;cat' -o build/applet_table_gen.c
#
#   # See which modules are needed
#   gen-applet-table.sh --applets 'curl;jq;ls;sort' --list-modules
#   # Output: core curl jq coreutils

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DEF_FILE="${SCRIPT_DIR}/../src/applets.def"
OUTPUT=""
APPLETS=""
MODULES=""
LIST_MODULES=0
LIST_APPLETS=0

usage() {
    sed -n '2,/^$/{ s/^# \?//; p; }' "$0"
    exit "${1:-0}"
}

while [[ $# -gt 0 ]]; do
    case "$1" in
        -d|--def)       DEF_FILE="$2"; shift 2 ;;
        -a|--applets)   APPLETS="$2"; shift 2 ;;
        -m|--modules)   MODULES="$2"; shift 2 ;;
        -o|--output)    OUTPUT="$2"; shift 2 ;;
        --list-modules) LIST_MODULES=1; shift ;;
        --list-applets) LIST_APPLETS=1; shift ;;
        -h|--help)      usage 0 ;;
        *)              echo "Unknown option: $1" >&2; usage 1 ;;
    esac
done

if [[ ! -f "$DEF_FILE" ]]; then
    echo "Error: applets.def not found: $DEF_FILE" >&2
    exit 1
fi

# Parse applets.def into arrays
declare -a ALL_MODULES=()
declare -a ALL_COMMANDS=()
declare -a ALL_FUNCS=()
declare -a ALL_CONDITIONS=()

while IFS=$'\t ' read -r module command func condition rest; do
    # Skip comments and empty lines
    [[ -z "$module" || "$module" == \#* ]] && continue
    ALL_MODULES+=("$module")
    ALL_COMMANDS+=("$command")
    ALL_FUNCS+=("$func")
    ALL_CONDITIONS+=("${condition:-}")
done < "$DEF_FILE"

# Build filter sets
declare -A applet_filter=()
declare -A module_filter=()

if [[ -n "$APPLETS" ]]; then
    IFS=';,' read -ra names <<< "$APPLETS"
    for name in "${names[@]}"; do
        name="${name## }"; name="${name%% }"
        [[ -n "$name" ]] && applet_filter["$name"]=1
    done
    # Always include core module's busyq applet
    applet_filter["busyq"]=1
fi

if [[ -n "$MODULES" ]]; then
    IFS=';,' read -ra mods <<< "$MODULES"
    for mod in "${mods[@]}"; do
        mod="${mod## }"; mod="${mod%% }"
        [[ -n "$mod" ]] && module_filter["$mod"]=1
    done
    # Always include core module
    module_filter["core"]=1
fi

# Determine which applets are active
declare -a ACTIVE_IDX=()
for i in "${!ALL_COMMANDS[@]}"; do
    if [[ ${#applet_filter[@]} -gt 0 ]]; then
        [[ -z "${applet_filter[${ALL_COMMANDS[$i]}]:-}" ]] && continue
    fi
    if [[ ${#module_filter[@]} -gt 0 ]]; then
        [[ -z "${module_filter[${ALL_MODULES[$i]}]:-}" ]] && continue
    fi
    ACTIVE_IDX+=("$i")
done

# --list-applets: print all available applet names and exit
if [[ $LIST_APPLETS -eq 1 ]]; then
    for i in "${!ALL_COMMANDS[@]}"; do
        echo "${ALL_COMMANDS[$i]}"
    done
    exit 0
fi

# --list-modules: print unique module names for active applets and exit
if [[ $LIST_MODULES -eq 1 ]]; then
    declare -A seen=()
    for i in "${ACTIVE_IDX[@]}"; do
        mod="${ALL_MODULES[$i]}"
        if [[ -z "${seen[$mod]:-}" ]]; then
            echo "$mod"
            seen["$mod"]=1
        fi
    done
    exit 0
fi

# Collect unique entry functions and conditions for extern declarations
declare -A extern_funcs=()
declare -A active_modules=()
for i in "${ACTIVE_IDX[@]}"; do
    func="${ALL_FUNCS[$i]}"
    cond="${ALL_CONDITIONS[$i]}"
    # Skip busyq_help_main (defined locally)
    [[ "$func" == "busyq_help_main" ]] && continue
    extern_funcs["$func"]="${cond}"
    active_modules["${ALL_MODULES[$i]}"]=1
done

# Generate C source
generate() {
    cat << 'HEADER'
/*
 * applet_table.c - Applet dispatch for busyq
 *
 * AUTO-GENERATED by scripts/gen-applet-table.sh from src/applets.def
 * Do not edit manually — edit applets.def and re-run the generator.
 *
 * Each embedded tool has a renamed main() that we call from the forked
 * child process in bash's shell_execve().  New upstream packages are
 * added here as {name, main_func} entries.
 *
 * Multi-call packages (coreutils) use a single dispatch entry point
 * that routes based on argv[0], similar to how busybox worked.
 */

#include "applet_table.h"
#include <string.h>
#include <unistd.h>

HEADER

    # Extern declarations
    echo "/* External tool entry points */"
    for func in $(echo "${!extern_funcs[@]}" | tr ' ' '\n' | sort -u); do
        cond="${extern_funcs[$func]}"
        if [[ -n "$cond" ]]; then
            echo "#ifdef $cond"
            echo "extern int ${func}(int argc, char **argv);"
            echo "#endif"
        else
            echo "extern int ${func}(int argc, char **argv);"
        fi
    done
    echo ""

    echo "static int busyq_help_main(int argc, char **argv);"
    echo ""

    # Applet table
    cat << 'TABLE_HDR'
/*
 * Applet table.  For multi-call packages like coreutils, each command
 * name maps to the same dispatch function — it routes on argv[0].
 */
static const struct busyq_applet applets[] = {
TABLE_HDR

    local prev_module=""
    for i in "${ACTIVE_IDX[@]}"; do
        local module="${ALL_MODULES[$i]}"
        local command="${ALL_COMMANDS[$i]}"
        local func="${ALL_FUNCS[$i]}"
        local cond="${ALL_CONDITIONS[$i]}"

        # Section comment when module changes
        if [[ "$module" != "$prev_module" ]]; then
            [[ -n "$prev_module" ]] && echo ""
            echo "    /* --- ${module} --- */"
            prev_module="$module"
        fi

        # Pad command name for alignment
        local padded
        padded=$(printf '%-12s' "\"${command}\",")

        if [[ -n "$cond" ]]; then
            echo "#ifdef $cond"
            echo "    { ${padded} ${func}, 0 },"
            echo "#endif"
        else
            echo "    { ${padded} ${func}, 0 },"
        fi
    done

    cat << 'TABLE_FTR'
};
static const int applet_count = sizeof(applets) / sizeof(applets[0]);

const struct busyq_applet *busyq_find_applet(const char *name)
{
    int i;

    for (i = 0; i < applet_count; i++) {
        if (strcmp(name, applets[i].name) == 0)
            return &applets[i];
    }

    return NULL;
}

/*
 * List all available commands.
 * Invoked when argv[0] is "busyq" (not bash/sh).
 */
static int busyq_help_main(int argc, char **argv)
{
    int i, col;

    (void)argc;
    (void)argv;

    {
        const char hdr[] =
            "busyq - single-binary bash+curl+jq+coreutils\n\n"
            "Built-in commands:\n";
        write(STDOUT_FILENO, hdr, sizeof(hdr) - 1);
    }

    col = 0;
    for (i = 0; i < applet_count; i++) {
        int len = strlen(applets[i].name);
        if (col == 0) {
            write(STDOUT_FILENO, "  ", 2);
            col = 2;
        } else if (col + len + 2 > 78) {
            write(STDOUT_FILENO, "\n  ", 3);
            col = 2;
        } else {
            write(STDOUT_FILENO, ", ", 2);
            col += 2;
        }
        write(STDOUT_FILENO, applets[i].name, len);
        col += len;
    }
    write(STDOUT_FILENO, "\n", 1);

    return 0;
}
TABLE_FTR
}

if [[ -n "$OUTPUT" ]]; then
    mkdir -p "$(dirname "$OUTPUT")"
    generate > "$OUTPUT"
else
    generate
fi
