#!/usr/bin/env bash
# busyq-scan — Analyze bash scripts for busyq custom builds
#
# Parses one or more bash scripts to detect command references and reports:
#   - Commands available as busyq applets (with module info)
#   - Bash builtins (always available, no applet needed)
#   - Path-based invocations (always use external binary)
#   - External commands not available in busyq
#   - eval/source warnings (opaque or indirect command execution)
#   - Function definitions within the script
#
# Usage:
#   busyq-scan [options] <script> [script...]
#
# Options:
#   --applets       List only busyq applet names needed (one per line)
#   --modules       List only busyq module names needed (one per line)
#   --cmake         Output a cmake -D definition for BUSYQ_APPLETS
#   --json          Output in JSON format
#   -q, --quiet     Suppress informational output, only show warnings
#   -h, --help      Show this help
#
# Exit codes:
#   0  Success
#   1  Usage error
#   2  Input file not found
#
# Limitations:
#   - Static analysis only — does not execute the script
#   - eval arguments are not analyzed (reported as warnings)
#   - Variable-based commands ($cmd args) cannot be resolved
#   - Aliases and functions from sourced files are not followed
#   - Complex parameter expansions may confuse the tokenizer
#   - Nested here-docs are not supported

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
APPLETS_DEF="${SCRIPT_DIR}/../src/applets.def"

# --- Output mode ---
MODE="report"   # report | applets | modules | cmake | json
QUIET=0

usage() {
    sed -n '2,/^$/{ s/^# \?//; p; }' "$0"
    exit "${1:-0}"
}

while [[ $# -gt 0 ]]; do
    case "$1" in
        --applets)  MODE="applets"; shift ;;
        --modules)  MODE="modules"; shift ;;
        --cmake)    MODE="cmake"; shift ;;
        --json)     MODE="json"; shift ;;
        -q|--quiet) QUIET=1; shift ;;
        -h|--help)  usage 0 ;;
        --)         shift; break ;;
        -*)         echo "Unknown option: $1" >&2; usage 1 ;;
        *)          break ;;
    esac
done

if [[ $# -eq 0 ]]; then
    echo "Error: no input files" >&2
    usage 1
fi

for f in "$@"; do
    if [[ ! -f "$f" ]]; then
        echo "Error: file not found: $f" >&2
        exit 2
    fi
done

# =====================================================================
# Load the busyq applet registry
# =====================================================================
declare -A BUSYQ_APPLET_MODULE=()  # command -> module
if [[ -f "$APPLETS_DEF" ]]; then
    while IFS=$'\t ' read -r module command func condition rest; do
        [[ -z "$module" || "$module" == \#* ]] && continue
        BUSYQ_APPLET_MODULE["$command"]="$module"
    done < "$APPLETS_DEF"
fi

# =====================================================================
# Bash builtins — always available, no applet needed
# =====================================================================
# Some commands (echo, printf, test, [, true, false, kill, pwd) are
# both bash builtins and coreutils applets.  Bash uses its builtin
# version, so these don't require the coreutils module.
declare -A BASH_BUILTINS=()
for b in \
    . : source eval exec exit return \
    alias unalias \
    bg fg jobs wait disown suspend \
    bind caller cd command compgen complete compopt \
    declare typeset local export readonly \
    dirs pushd popd \
    echo enable fc getopts hash help history \
    jobs kill let logout \
    mapfile readarray \
    printf pwd read \
    set shopt shift \
    test trap times type \
    ulimit umask unset \
    true false \
    '[' '[[' \
    break continue \
; do
    BASH_BUILTINS["$b"]=1
done

# =====================================================================
# Shell keywords — not commands, skip when seen
# =====================================================================
declare -A SHELL_KEYWORDS=()
for k in \
    if then else elif fi \
    case esac in \
    for select while until do done \
    function time coproc \
    '!' '{' '}' ']]' \
; do
    SHELL_KEYWORDS["$k"]=1
done

# =====================================================================
# Command extractor (awk)
#
# Processes bash source and outputs tab-separated records:
#   CMD    <name>    <file>    <line>
#   EVAL   <expr>    <file>    <line>
#   SOURCE <path>    <file>    <line>
#   FUNC   <name>    <file>    <line>
#   PATH   <path>    <file>    <line>    (invocations containing /)
# =====================================================================
extract_commands() {
    awk '
# ---- helpers ----
function strip_comment(s,    i, c, len, in_sq, in_dq, result) {
    result = ""
    in_sq = 0
    in_dq = 0
    len = length(s)
    for (i = 1; i <= len; i++) {
        c = substr(s, i, 1)
        if (in_sq) {
            result = result c
            if (c == "'\''") in_sq = 0
        } else if (in_dq) {
            result = result c
            if (c == "\\") { i++; result = result substr(s, i, 1) }
            else if (c == "\"") in_dq = 0
        } else {
            if (c == "'\''") { in_sq = 1; result = result c }
            else if (c == "\"") { in_dq = 1; result = result c }
            else if (c == "#") break
            else result = result c
        }
    }
    return result
}

function is_keyword(w) {
    return (w == "if" || w == "then" || w == "else" || w == "elif" || \
            w == "fi" || w == "case" || w == "esac" || w == "for" || \
            w == "select" || w == "while" || w == "until" || w == "do" || \
            w == "done" || w == "in" || w == "function" || w == "time" || \
            w == "coproc" || w == "{" || w == "}" || w == "!" || w == "]]")
}

function is_redirect(w) {
    return (w ~ /^[0-9]*[<>]/ || w == "<" || w == ">" || w == ">>" || \
            w == "<<<" || w == "2>&1" || w == "&>" || w == "&>>")
}

function is_assignment(w) {
    return (w ~ /^[A-Za-z_][A-Za-z0-9_]*\+?=/)
}

# Emit a command record.  For CMD/PATH tags, strip quotes and skip
# variable references.  For EVAL/SOURCE/FUNC, pass through as-is
# since the value is informational, not a command to classify.
function emit(tag, word, file, lineno) {
    if (tag == "CMD" || tag == "PATH") {
        gsub(/^["'\''"]|["'\''"]$/, "", word)
        if (word == "" || word ~ /^\$/) return
    } else {
        if (word == "") return
    }
    printf "%s\t%s\t%s\t%d\n", tag, word, file, lineno
}

# Quote-aware tokenizer: splits a string on unquoted whitespace.
# Returns tokens in out[], returns token count.
function qtokenize(s, out,    n, i, c, len, in_sq, in_dq, tok) {
    n = 0
    tok = ""
    in_sq = 0
    in_dq = 0
    len = length(s)
    for (i = 1; i <= len; i++) {
        c = substr(s, i, 1)
        if (in_sq) {
            tok = tok c
            if (c == "'\''") in_sq = 0
        } else if (in_dq) {
            tok = tok c
            if (c == "\\") { i++; tok = tok substr(s, i, 1) }
            else if (c == "\"") in_dq = 0
        } else if (c == "'\''") {
            in_sq = 1; tok = tok c
        } else if (c == "\"") {
            in_dq = 1; tok = tok c
        } else if (c == " " || c == "\t") {
            if (tok != "") { out[++n] = tok; tok = "" }
        } else {
            tok = tok c
        }
    }
    if (tok != "") out[++n] = tok
    return n
}

# Strip surrounding quotes from a token for comparison purposes
function unquote(s) {
    gsub(/^["'\''"]|["'\''"]$/, "", s)
    return s
}

# Extract commands from a single "statement" string
function process_stmt(stmt, file, lineno,    nt, toks, j, tok, base, utok, expr) {
    # Trim leading whitespace
    gsub(/^[[:space:]]+/, "", stmt)
    if (stmt == "") return

    # Use quote-aware tokenizer
    delete toks
    nt = qtokenize(stmt, toks)

    for (j = 1; j <= nt; j++) {
        tok = toks[j]
        if (tok == "") continue

        utok = unquote(tok)

        # Skip redirections (and their targets)
        if (is_redirect(utok)) { j++; continue }

        # Skip variable assignments before the command
        if (is_assignment(tok)) continue

        # Handle "for VAR in ..." — skip the loop variable
        if (utok == "for" || utok == "select") {
            j++  # skip loop variable
            # skip to past "in" or "do"
            for (j++; j <= nt; j++) {
                if (unquote(toks[j]) == "in" || unquote(toks[j]) == "do") break
            }
            continue
        }

        # Handle "case EXPR in" — skip to past "in"
        if (utok == "case") {
            for (j++; j <= nt; j++) {
                if (unquote(toks[j]) == "in") break
            }
            continue
        }

        # Skip other keywords
        if (is_keyword(utok)) continue

        # Skip negation prefix
        if (utok == "!") continue

        # Check for function definition: word() or word ()
        if (j < nt && unquote(toks[j+1]) ~ /^\(\)/) {
            emit("FUNC", utok, file, lineno)
            return
        }
        if (utok ~ /\(\)$/) {
            sub(/\(\)$/, "", utok)
            emit("FUNC", utok, file, lineno)
            return
        }
        # "function" keyword is handled above as a keyword but next
        # token is the function name — it will be extracted as a CMD,
        # which is then classified in the bash wrapper

        # Path-based invocation (contains /)
        if (utok ~ /\//) {
            emit("PATH", utok, file, lineno)
            return
        }

        # Skip variable references as commands ($cmd, ${cmd})
        if (utok ~ /^\$/) continue

        # Detect eval
        if (utok == "eval") {
            # Capture the rest of the statement as the eval expression
            expr = ""
            for (j++; j <= nt; j++) expr = expr " " toks[j]
            gsub(/^[[:space:]]+/, "", expr)
            if (expr == "") expr = "(empty)"
            emit("EVAL", expr, file, lineno)
            return
        }

        # Detect source / .
        if (utok == "source" || (utok == "." && j < nt)) {
            if (j < nt) {
                emit("SOURCE", unquote(toks[j+1]), file, lineno)
            }
            return
        }

        # Normal command
        emit("CMD", utok, file, lineno)

        # Commands that take another command as their argument
        base = utok
        sub(/.*\//, "", base)
        if (base == "xargs" || base == "nice" || base == "nohup" || \
            base == "env" || base == "sudo" || base == "exec") {
            for (j++; j <= nt; j++) {
                tok = toks[j]
                utok = unquote(tok)
                if (utok ~ /^-/) continue
                if (is_assignment(tok)) continue
                if (utok ~ /\//) {
                    emit("PATH", utok, file, lineno)
                } else {
                    emit("CMD", utok, file, lineno)
                }
                break
            }
        } else if (base == "command") {
            for (j++; j <= nt; j++) {
                tok = toks[j]
                utok = unquote(tok)
                if (utok ~ /^-/) continue
                if (utok ~ /\//) {
                    emit("PATH", utok, file, lineno)
                } else {
                    emit("CMD", utok, file, lineno)
                }
                break
            }
        }
        return
    }
}

# Extract commands from $(...) and `...` substitutions in a line
function process_subst(line, file, lineno,    pos, depth, c, start, content) {
    # Handle $(...) — track parenthesis depth
    pos = 1
    while (pos < length(line)) {
        start = index(substr(line, pos), "$(")
        if (start == 0) break
        start = pos + start + 1  # position after "$("
        pos = start
        depth = 1
        while (pos <= length(line) && depth > 0) {
            c = substr(line, pos, 1)
            if (c == "(") depth++
            else if (c == ")") depth--
            if (depth > 0) pos++
            else break
        }
        if (depth == 0) {
            content = substr(line, start, pos - start)
            process_stmt(content, file, lineno)
        }
        pos++
    }

    # Handle `...` backtick substitutions
    pos = 1
    while (pos < length(line)) {
        start = index(substr(line, pos), "`")
        if (start == 0) break
        start = pos + start  # position after first backtick
        end_pos = index(substr(line, start), "`")
        if (end_pos == 0) break
        content = substr(line, start, end_pos - 1)
        process_stmt(content, file, lineno)
        pos = start + end_pos
    }
}

# ---- main processing ----
BEGIN {
    in_heredoc = 0
    heredoc_delim = ""
    continuation = ""
}

# Skip heredoc body
in_heredoc == 1 {
    # Check for end delimiter (may be indented if <<-)
    test_line = $0
    gsub(/^[[:space:]]+/, "", test_line)
    if (test_line == heredoc_delim) {
        in_heredoc = 0
        heredoc_delim = ""
    }
    next
}

{
    # Handle line continuations
    if (continuation != "") {
        $0 = continuation $0
        continuation = ""
    }
    if (/\\$/) {
        sub(/\\$/, "", $0)
        continuation = $0
        next
    }

    line = strip_comment($0)

    # Skip empty and shebang lines
    if (line ~ /^[[:space:]]*$/) next
    if (NR == 1 && line ~ /^#!/) next

    # Detect heredoc start (store delimiter, process the line normally)
    if (match(line, /<<-?[[:space:]]*\\?['\''"]?([A-Za-z_][A-Za-z0-9_]*)['\''"]?/)) {
        rest = substr(line, RSTART + RLENGTH)
        # Extract the delimiter from the match
        delim_part = substr(line, RSTART, RLENGTH)
        gsub(/<<-?[[:space:]]*\\?['\''"]?/, "", delim_part)
        gsub(/['\''"].*/, "", delim_part)
        if (delim_part != "") {
            heredoc_delim = delim_part
            in_heredoc = 1
        }
    }

    # Process command substitutions ($(...) and `...`) first
    process_subst(line, FILENAME, NR)

    # Split line into statements at ; && || | boundaries
    # Protect function-definition () from being split as subshell
    gsub(/\(\)/, "\x02\x03", line)
    # Replace 2-char operators first, then single-char
    gsub(/&&/, "\x01", line)
    gsub(/\|\|/, "\x01", line)
    gsub(/\|/, "\x01", line)
    gsub(/;/, "\x01", line)
    gsub(/\(/, "\x01", line)
    gsub(/\)/, " ", line)
    # Restore function-definition ()
    gsub(/\x02\x03/, "()", line)

    n = split(line, stmts, "\x01")
    for (si = 1; si <= n; si++) {
        process_stmt(stmts[si], FILENAME, NR)
    }
}
' "$@"
}

# =====================================================================
# Run the extractor and collect results
# =====================================================================
declare -A FOUND_CMDS=()        # command -> "file:line file:line ..."
declare -A FOUND_EVALS=()       # "file:line" -> expression
declare -A FOUND_SOURCES=()     # "file:line" -> path
declare -A FOUND_FUNCS=()       # funcname -> "file:line"
declare -A FOUND_PATHS=()       # path -> "file:line file:line ..."

while IFS=$'\t' read -r tag value file lineno; do
    case "$tag" in
        CMD)
            FOUND_CMDS["$value"]+="${file}:${lineno} "
            ;;
        EVAL)
            FOUND_EVALS["${file}:${lineno}"]="$value"
            ;;
        SOURCE)
            FOUND_SOURCES["${file}:${lineno}"]="$value"
            ;;
        FUNC)
            FOUND_FUNCS["$value"]="${file}:${lineno}"
            ;;
        PATH)
            FOUND_PATHS["$value"]+="${file}:${lineno} "
            ;;
    esac
done < <(extract_commands "$@")

# =====================================================================
# Classify commands
# =====================================================================
declare -A CLASS_BUILTIN=()     # bash builtins
declare -A CLASS_APPLET=()      # busyq applets (value = module)
declare -A CLASS_FUNCTION=()    # functions defined in the script
declare -A CLASS_EXTERNAL=()    # commands not available in busyq

for cmd in "${!FOUND_CMDS[@]}"; do
    # Shell keywords shouldn't appear but filter them out
    [[ -n "${SHELL_KEYWORDS[$cmd]:-}" ]] && continue

    # Functions defined in the scanned scripts
    if [[ -n "${FOUND_FUNCS[$cmd]:-}" ]]; then
        CLASS_FUNCTION["$cmd"]=1
        continue
    fi

    # Bash builtins
    if [[ -n "${BASH_BUILTINS[$cmd]:-}" ]]; then
        CLASS_BUILTIN["$cmd"]=1
        continue
    fi

    # Busyq applets
    if [[ -n "${BUSYQ_APPLET_MODULE[$cmd]:-}" ]]; then
        CLASS_APPLET["$cmd"]="${BUSYQ_APPLET_MODULE[$cmd]}"
        continue
    fi

    # External / unavailable
    CLASS_EXTERNAL["$cmd"]=1
done

# Collect unique modules needed
declare -A NEEDED_MODULES=()
for cmd in "${!CLASS_APPLET[@]}"; do
    NEEDED_MODULES["${CLASS_APPLET[$cmd]}"]=1
done

# =====================================================================
# Output
# =====================================================================

# --- Machine-readable modes ---
if [[ "$MODE" == "applets" ]]; then
    for cmd in "${!CLASS_APPLET[@]}"; do
        echo "$cmd"
    done | sort
    exit 0
fi

if [[ "$MODE" == "modules" ]]; then
    for mod in "${!NEEDED_MODULES[@]}"; do
        echo "$mod"
    done | sort
    exit 0
fi

if [[ "$MODE" == "cmake" ]]; then
    applet_list=$(for cmd in "${!CLASS_APPLET[@]}"; do echo "$cmd"; done | sort | tr '\n' ';')
    applet_list="${applet_list%;}"  # remove trailing semicolon
    echo "-DBUSYQ_APPLETS=${applet_list}"
    exit 0
fi

if [[ "$MODE" == "json" ]]; then
    # Output JSON using printf (no jq dependency)
    echo "{"

    # applets
    echo '  "applets": {'
    first=1
    for cmd in $(for c in "${!CLASS_APPLET[@]}"; do echo "$c"; done | sort); do
        [[ $first -eq 0 ]] && echo ","
        printf '    "%s": "%s"' "$cmd" "${CLASS_APPLET[$cmd]}"
        first=0
    done
    echo ""
    echo "  },"

    # builtins
    echo '  "builtins": ['
    first=1
    for cmd in $(for c in "${!CLASS_BUILTIN[@]}"; do echo "$c"; done | sort); do
        [[ $first -eq 0 ]] && echo ","
        printf '    "%s"' "$cmd"
        first=0
    done
    echo ""
    echo "  ],"

    # functions
    echo '  "functions": ['
    first=1
    for cmd in $(for c in "${!CLASS_FUNCTION[@]}"; do echo "$c"; done | sort); do
        [[ $first -eq 0 ]] && echo ","
        printf '    "%s"' "$cmd"
        first=0
    done
    echo ""
    echo "  ],"

    # external
    echo '  "external": ['
    first=1
    for cmd in $(for c in "${!CLASS_EXTERNAL[@]}"; do echo "$c"; done | sort); do
        [[ $first -eq 0 ]] && echo ","
        printf '    "%s"' "$cmd"
        first=0
    done
    echo ""
    echo "  ],"

    # path_invocations
    echo '  "path_invocations": ['
    first=1
    for p in $(for c in "${!FOUND_PATHS[@]}"; do echo "$c"; done | sort); do
        [[ $first -eq 0 ]] && echo ","
        printf '    "%s"' "$p"
        first=0
    done
    echo ""
    echo "  ],"

    # eval_warnings
    echo '  "eval_warnings": ['
    first=1
    for loc in $(for c in "${!FOUND_EVALS[@]}"; do echo "$c"; done | sort); do
        [[ $first -eq 0 ]] && echo ","
        # Escape double quotes in the expression
        expr="${FOUND_EVALS[$loc]}"
        expr="${expr//\\/\\\\}"
        expr="${expr//\"/\\\"}"
        printf '    {"location": "%s", "expression": "%s"}' "$loc" "$expr"
        first=0
    done
    echo ""
    echo "  ],"

    # source_files
    echo '  "source_files": ['
    first=1
    for loc in $(for c in "${!FOUND_SOURCES[@]}"; do echo "$c"; done | sort); do
        [[ $first -eq 0 ]] && echo ","
        printf '    {"location": "%s", "path": "%s"}' "$loc" "${FOUND_SOURCES[$loc]}"
        first=0
    done
    echo ""
    echo "  ],"

    # modules
    echo '  "modules": ['
    first=1
    for mod in $(for c in "${!NEEDED_MODULES[@]}"; do echo "$c"; done | sort); do
        [[ $first -eq 0 ]] && echo ","
        printf '    "%s"' "$mod"
        first=0
    done
    echo ""
    echo "  ]"

    echo "}"
    exit 0
fi

# --- Human-readable report ---
echo "busyq-scan: analyzed $# file(s)"
echo ""

# Busyq applets
if [[ ${#CLASS_APPLET[@]} -gt 0 ]]; then
    echo "Busyq applets needed (${#CLASS_APPLET[@]}):"
    for cmd in $(for c in "${!CLASS_APPLET[@]}"; do echo "$c"; done | sort); do
        printf "  %-20s [%s]\n" "$cmd" "${CLASS_APPLET[$cmd]}"
    done
    echo ""
fi

# Bash builtins
if [[ $QUIET -eq 0 && ${#CLASS_BUILTIN[@]} -gt 0 ]]; then
    echo "Bash builtins (always available):"
    echo -n " "
    for cmd in $(for c in "${!CLASS_BUILTIN[@]}"; do echo "$c"; done | sort); do
        echo -n " $cmd"
    done
    echo ""
    echo ""
fi

# Script functions
if [[ $QUIET -eq 0 && ${#CLASS_FUNCTION[@]} -gt 0 ]]; then
    echo "Functions defined in script:"
    for cmd in $(for c in "${!CLASS_FUNCTION[@]}"; do echo "$c"; done | sort); do
        echo "  $cmd  (${FOUND_FUNCS[$cmd]})"
    done
    echo ""
fi

# Warnings section
has_warnings=0

if [[ ${#FOUND_EVALS[@]} -gt 0 ]]; then
    has_warnings=1
    echo "WARNING: eval usage detected (commands inside eval cannot be analyzed):"
    for loc in $(for c in "${!FOUND_EVALS[@]}"; do echo "$c"; done | sort); do
        echo "  $loc: eval ${FOUND_EVALS[$loc]}"
    done
    echo ""
fi

if [[ ${#FOUND_PATHS[@]} -gt 0 ]]; then
    has_warnings=1
    echo "WARNING: Path-based invocations (always use external binary):"
    for p in $(for c in "${!FOUND_PATHS[@]}"; do echo "$c"; done | sort); do
        locs="${FOUND_PATHS[$p]}"
        echo "  $p  (${locs% })"
    done
    echo ""
fi

if [[ ${#FOUND_SOURCES[@]} -gt 0 ]]; then
    has_warnings=1
    echo "NOTE: Sourced files (should also be scanned):"
    for loc in $(for c in "${!FOUND_SOURCES[@]}"; do echo "$c"; done | sort); do
        echo "  $loc: source ${FOUND_SOURCES[$loc]}"
    done
    echo ""
fi

if [[ ${#CLASS_EXTERNAL[@]} -gt 0 ]]; then
    has_warnings=1
    echo "External commands (not available in busyq):"
    for cmd in $(for c in "${!CLASS_EXTERNAL[@]}"; do echo "$c"; done | sort); do
        locs="${FOUND_CMDS[$cmd]}"
        echo "  $cmd  (${locs% })"
    done
    echo ""
fi

# Summary
echo "---"
if [[ ${#NEEDED_MODULES[@]} -gt 0 ]]; then
    mod_list=$(for mod in "${!NEEDED_MODULES[@]}"; do echo "$mod"; done | sort | tr '\n' ',' | sed 's/,$//')
    echo "Busyq modules needed: $mod_list"
fi

applet_list=$(for cmd in "${!CLASS_APPLET[@]}"; do echo "$cmd"; done | sort | tr '\n' ';' | sed 's/;$//')
if [[ -n "$applet_list" ]]; then
    echo ""
    echo "To build a minimal busyq for these scripts:"
    echo "  cmake --preset no-ssl -DBUSYQ_APPLETS=\"${applet_list}\""
fi
echo ""
