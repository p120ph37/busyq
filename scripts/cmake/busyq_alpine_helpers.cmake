# busyq_alpine_helpers.cmake - Download and patch source using Alpine-synced metadata
#
# Provides busyq_alpine_source() which reads an alpine-source.cmake file
# (generated by scripts/sync-alpine.sh), downloads the upstream tarball,
# applies Alpine patches, and returns the patched source path.
#
# Usage in portfile.cmake:
#
#   include("${CMAKE_CURRENT_LIST_DIR}/../../scripts/cmake/busyq_alpine_helpers.cmake")
#
#   busyq_alpine_source(
#       PORT_DIR "${CMAKE_CURRENT_LIST_DIR}"
#       OUT_SOURCE_PATH SOURCE_PATH
#   )
#
# For multi-source ports (e.g., zip + unzip with separate Alpine packages):
#
#   busyq_alpine_source(
#       PORT_DIR "${CMAKE_CURRENT_LIST_DIR}"
#       SUBDIR zip
#       OUT_SOURCE_PATH ZIP_SOURCE_PATH
#   )
#
# Optional parameters:
#   EXTRA_PATCHES   - Additional patch files to apply after Alpine patches
#   EXTRA_URLS      - Additional mirror URLs appended to ALPINE_SOURCE_URLS
#   USE_PATCH_CMD   - Use `patch -p1` instead of git apply (for fuzzy matching
#                     when patches have overlapping context, e.g., unzip CVEs)

function(busyq_alpine_source)
    cmake_parse_arguments(PARSE_ARGV 0 ARG "USE_PATCH_CMD" "PORT_DIR;SUBDIR;OUT_SOURCE_PATH" "EXTRA_PATCHES;EXTRA_URLS")

    # Include the alpine-source cmake file (sets ALPINE_* variables)
    if(ARG_SUBDIR)
        include("${ARG_PORT_DIR}/alpine-source-${ARG_SUBDIR}.cmake")
        set(_patches_dir "${ARG_PORT_DIR}/patches/${ARG_SUBDIR}")
    else()
        include("${ARG_PORT_DIR}/alpine-source.cmake")
        set(_patches_dir "${ARG_PORT_DIR}/patches")
    endif()

    # Build full URL list (Alpine primary + extra mirrors)
    set(_urls ${ALPINE_SOURCE_URLS})
    if(ARG_EXTRA_URLS)
        list(APPEND _urls ${ARG_EXTRA_URLS})
    endif()

    # Download source tarball
    vcpkg_download_distfile(_archive
        URLS ${_urls}
        FILENAME "${ALPINE_SOURCE_FILENAME}"
        SHA512 ${ALPINE_SOURCE_SHA512}
    )

    # Build list of Alpine patch file paths
    set(_patch_paths "")
    foreach(_patch ${ALPINE_PATCHES})
        list(APPEND _patch_paths "${_patches_dir}/${_patch}")
    endforeach()

    # Append any extra busyq-specific patches
    if(ARG_EXTRA_PATCHES)
        list(APPEND _patch_paths ${ARG_EXTRA_PATCHES})
    endif()

    if(ARG_USE_PATCH_CMD AND _patch_paths)
        # Extract WITHOUT patches, then apply manually with `patch -p1`
        # which supports fuzzy matching (needed for complex patch sets
        # where patches have overlapping context, like unzip's 30 CVE patches)
        vcpkg_extract_source_archive(_source_path
            ARCHIVE "${_archive}"
        )
        foreach(_patch_file ${_patch_paths})
            get_filename_component(_patch_name "${_patch_file}" NAME)
            message(STATUS "Applying patch (patch -p1): ${_patch_name}")
            vcpkg_execute_required_process(
                COMMAND patch -p1 -i "${_patch_file}"
                WORKING_DIRECTORY "${_source_path}"
                LOGNAME "patch-${_patch_name}-${TARGET_TRIPLET}"
            )
        endforeach()
    else()
        # Standard vcpkg patch application (uses git apply, strict matching)
        vcpkg_extract_source_archive(_source_path
            ARCHIVE "${_archive}"
            PATCHES ${_patch_paths}
        )
    endif()

    set(${ARG_OUT_SOURCE_PATH} "${_source_path}" PARENT_SCOPE)
endfunction()
