diff --git a/execute_cmd.c b/execute_cmd.c
index 070f511..a1b3c4e 100644
--- a/execute_cmd.c
+++ b/execute_cmd.c
@@ -80,6 +80,9 @@ extern int errno;
 #include "pathexp.h"
 #include "hashcmd.h"

+/* busyq: applet table for embedded command dispatch */
+#include "busyq_applet_table.h"
+
 #if defined (COND_COMMAND)
 #  include "test.h"
 #endif
@@ -6126,6 +6129,31 @@ shell_execve (char *command, char **args, char **env)
   int i, fd, sample_len;
   char sample[HASH_BANG_BUFSIZ];
   size_t larray;
+
+  /* busyq: If the command resolves to an embedded applet, dispatch it
+   * directly instead of calling execve().  At this point we are already
+   * inside the forked child created by execute_disk_command() via
+   * make_child(), so bash has set up pipes, redirections, signals, and
+   * job control.  We call the applet's main function and then _exit()
+   * to terminate the child, just as a successful execve() would replace
+   * the process.  fflush(NULL) ensures buffered output is written since
+   * _exit() does not run atexit handlers or flush stdio. */
+  {
+    const struct busyq_applet *applet;
+    if (args && args[0])
+      {
+        applet = busyq_find_applet (args[0]);
+        if (applet)
+          {
+            int ac, ret;
+            for (ac = 0; args[ac]; ac++)
+              ;
+            ret = applet->main_func (ac, args);
+            fflush (NULL);
+            _exit (ret);
+          }
+      }
+  }

   SETOSTYPE (0);		/* Some systems use for USG/POSIX semantics */
   execve (command, args, env);
