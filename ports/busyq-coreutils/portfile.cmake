include("${CMAKE_CURRENT_LIST_DIR}/../../scripts/cmake/busyq_alpine_helpers.cmake")

busyq_alpine_source(
    PORT_DIR "${CMAKE_CURRENT_LIST_DIR}"
    OUT_SOURCE_PATH SOURCE_PATH
    USE_PATCH_CMD
)

# Detect toolchain flags (CC, CFLAGS with LTO/optimization) before autotools
# claims the build directory.
vcpkg_cmake_get_vars(cmake_vars_file)
include("${cmake_vars_file}")

# Only build release (debug artifacts are unused)
set(VCPKG_BUILD_TYPE release)

# --- Generate compile-time symbol prefix header ---
#
# Coreutils and bash both embed gnulib, causing massive symbol collisions
# (xmalloc, hash_insert, quotearg, etc.) when statically linked.
#
# Previous approach: objcopy --prefix-symbols=cu_  (BREAKS LLVM bitcode)
# New approach: -include cu_prefix.h  (preserves bitcode for full LTO)
#
# Algorithm:
#   1. Extract all globally-defined symbols from bash's installed libraries
#   2. Subtract libc/system symbols (which must not be renamed)
#   3. Generate #define sym cu_sym for each remaining symbol
#
# This header is force-included into every coreutils translation unit via
# CPPFLAGS=-include cu_prefix.h, renaming collision candidates at the
# preprocessor level while preserving LLVM bitcode for cross-project LTO.

set(_prefix_h "${SOURCE_PATH}/cu_prefix.h")
set(_bash_lib_dir "${CURRENT_INSTALLED_DIR}/lib")

vcpkg_execute_required_process(
    COMMAND sh -c "
        set -e

        # Step 1: Defined global symbols from all bash libraries
        for lib in libbash.a libbuiltins.a libreadline.a libhistory.a libglob.a libtilde.a libsh.a; do
            [ -f '${_bash_lib_dir}/'$lib ] && nm --defined-only -g '${_bash_lib_dir}/'$lib 2>/dev/null || true
        done | awk 'NF>=3 && $2~/[A-Z]/ {print $3}' | sort -u > /tmp/cu_bash_defined.txt

        # Step 2: Defined global symbols from libc (must NOT be prefixed)
        nm --defined-only -g /usr/lib/libc.a 2>/dev/null \
            | awk 'NF>=3 && $2~/[A-Z]/ {print $3}' | sort -u > /tmp/cu_libc_syms.txt

        # Also exclude well-known linker/runtime symbols
        printf '%s\n' main _start _init _fini __libc_start_main >> /tmp/cu_libc_syms.txt
        sort -u -o /tmp/cu_libc_syms.txt /tmp/cu_libc_syms.txt

        # Step 3: Collision candidates = bash-defined minus libc-defined
        comm -23 /tmp/cu_bash_defined.txt /tmp/cu_libc_syms.txt > /tmp/cu_prefix_syms.txt

        # Generate the prefix header
        {
            echo '/* Auto-generated by busyq-coreutils portfile */'
            echo '/* Compile-time symbol prefixing for gnulib collision avoidance */'
            echo '/* Preserves LLVM bitcode (replaces objcopy --prefix-symbols) */'
            echo '#ifndef CU_PREFIX_H'
            echo '#define CU_PREFIX_H'
            while IFS= read -r sym; do
                echo \"#define $sym cu_$sym\"
            done < /tmp/cu_prefix_syms.txt
            echo '#endif'
        } > '${_prefix_h}'

        count=\$(wc -l < /tmp/cu_prefix_syms.txt)
        echo \"Generated cu_prefix.h with \$count symbol renames\"
    "
    WORKING_DIRECTORY "${SOURCE_PATH}"
    LOGNAME "gen-cu-prefix-${TARGET_TRIPLET}"
)

# Build coreutils in single-binary mode.
# --enable-single-binary=symlinks: each tool's main() is renamed to
#   single_binary_main_TOOLNAME() via per-file -Dmain flags.  Our applet
#   table references these directly, bypassing the argv[0] dispatcher
#   so LTO can trace the static call graph and prune unused commands.
# --enable-no-install-program=stdbuf: stdbuf uses a shared library shim,
#   which is incompatible with our static-only approach.
# --without-libgmp: factor will use __int128 fallback (still handles large numbers)
# --without-openssl: no need for OpenSSL hash acceleration
# --without-selinux: not needed in distroless containers
# --disable-nls: no internationalization (smaller binary)
# FORCE_UNSAFE_CONFIGURE=1: allow running configure as root inside containers
set(ENV{FORCE_UNSAFE_CONFIGURE} "1")

vcpkg_configure_make(
    SOURCE_PATH "${SOURCE_PATH}"
    OPTIONS
        --enable-single-binary=symlinks
        "--enable-no-install-program=stdbuf"
        --without-libgmp
        --without-openssl
        --without-selinux
        --disable-nls
        --disable-acl
        --disable-xattr
)

# Build with the prefix header force-included.  CPPFLAGS is processed before
# per-program CFLAGS in autotools, so the per-tool -Dmain=single_binary_main_*
# flags (from --enable-single-binary) are unaffected by our prefix header
# (which does not define 'main').
vcpkg_build_make(
    LOGFILE_ROOT "build"
    OPTIONS "CPPFLAGS=-include ${_prefix_h}"
)

set(CU_BUILD_REL "${CURRENT_BUILDTREES_DIR}/${TARGET_TRIPLET}-rel")

file(MAKE_DIRECTORY "${CURRENT_PACKAGES_DIR}/lib")

# --- Collect objects and package ---
#
# Collect all .o files from the build.  We EXCLUDE the coreutils dispatcher
# object (src/coreutils.c → src_coreutils-coreutils.o) because:
#   1. It contains main(), which would conflict with our entry point
#   2. It uses dynamic argv[0] dispatch referencing ALL single_binary_main_*
#      functions, preventing LTO from pruning unused commands
#
# By excluding it, each command's single_binary_main_* becomes an independent
# LTO root.  Only commands referenced in the applet table survive linking.

file(GLOB_RECURSE CU_OBJS
    "${CU_BUILD_REL}/src/*.o"
    "${CU_BUILD_REL}/lib/*.o"
)
list(FILTER CU_OBJS EXCLUDE REGEX "/(tests|gnulib-tests|bench)/")

# Exclude the coreutils dispatcher (automake names it src_coreutils-coreutils.o
# when per-target CFLAGS are used, or coreutils.o otherwise)
list(FILTER CU_OBJS EXCLUDE REGEX "/src_coreutils-coreutils\\.o$")
list(FILTER CU_OBJS EXCLUDE REGEX "/src/coreutils\\.o$")

if(NOT CU_OBJS)
    message(FATAL_ERROR "No coreutils object files found in ${CU_BUILD_REL}")
endif()

# Pack into temporary archive (needed for ld -r --whole-archive)
vcpkg_execute_required_process(
    COMMAND ar rcs "${CU_BUILD_REL}/libcoreutils_raw.a" ${CU_OBJS}
    WORKING_DIRECTORY "${CU_BUILD_REL}"
    LOGNAME "ar-raw-${TARGET_TRIPLET}"
)

# Combine all objects with ld -r.  In the alpine-clang-vcpkg container,
# ld is aliased to lld which preserves LLVM bitcode sections.  This is
# the key advantage over the old objcopy approach: the combined object
# retains full bitcode, enabling cross-project LTO at final link time.
#
# -z muldefs resolves internal gnulib duplicates (e.g. xalloc_die
# defined in both gnulib and inlined into csplit.o).
vcpkg_execute_required_process(
    COMMAND sh -c "
        set -e
        ld -r --whole-archive libcoreutils_raw.a -o coreutils_combined.o \
            -z muldefs 2>/dev/null \
        || ld -r --whole-archive libcoreutils_raw.a -o coreutils_combined.o
        llvm-objcopy --wildcard --keep-global-symbol='single_binary_main_*' coreutils_combined.o

        # Package into final archive (no objcopy — bitcode preserved)
        ar rcs '${CURRENT_PACKAGES_DIR}/lib/libcoreutils.a' coreutils_combined.o
    "
    WORKING_DIRECTORY "${CU_BUILD_REL}"
    LOGNAME "combine-${TARGET_TRIPLET}"
)

# Suppress vcpkg post-build warnings — we only produce release libraries
# and coreutils has no public headers (it's a tool, not a library)
set(VCPKG_POLICY_MISMATCHED_NUMBER_OF_BINARIES enabled)
set(VCPKG_POLICY_EMPTY_INCLUDE_FOLDER enabled)

# Install copyright
vcpkg_install_copyright(FILE_LIST "${SOURCE_PATH}/COPYING")
