#!/bin/sh
# gen_busyq_applets.sh - Generate BUSYQ_BB_APPLET() entries from busybox build
#
# Parses busybox's generated include/applet_tables.h to extract the applet
# names, main functions, and flags (NOFORK/NOEXEC).
#
# Usage: gen_busyq_applets.sh <busybox-build-dir> <output-header>

set -eu

BB_BUILD="$1"
OUTPUT="$2"

# The generated applet_tables.h contains arrays like:
#   const char applet_names[] ALIGN1 = "name1\0name2\0..."
#   const char applet_main[] = { ... }
# But parsing that is complex.
#
# Instead, parse the preprocessed applets.h which defines APPLET macros.
# After busybox builds, include/applets.h is generated from applets.src.h.

APPLETS_H="$BB_BUILD/include/applets.h"
if [ ! -f "$APPLETS_H" ]; then
    # Try the source tree
    APPLETS_H="$(find "$BB_BUILD" -name "applets.h" -path "*/include/*" | head -1)"
fi

if [ ! -f "$APPLETS_H" ]; then
    echo "/* WARNING: Could not find applets.h, empty table */" > "$OUTPUT"
    exit 0
fi

cat > "$OUTPUT" << 'HEADER'
/*
 * busybox_applets.h - Auto-generated busybox applet table for busyq
 *
 * Generated by gen_busyq_applets.sh from busybox's include/applets.h
 * DO NOT EDIT - this file is regenerated during the build.
 *
 * Each entry is: BUSYQ_BB_APPLET(name_string, main_func, flags)
 * where flags is 0, BUSYQ_APPLET_NOFORK, or BUSYQ_APPLET_NOEXEC
 */
HEADER

# Parse APPLET lines from applets.h
# Formats:
#   IF_xxx(APPLET(name, BB_DIR_xxx, BB_SUID_xxx))
#   IF_xxx(APPLET_NOFORK(name, ...))
#   IF_xxx(APPLET_NOEXEC(name, ...))
#   IF_xxx(APPLET_ODDNAME(name, main_func, ...))
# The IF_xxx macros are already resolved by the build (present = enabled)

# Extract APPLET_NOFORK entries
grep -oP 'APPLET_NOFORK\(\s*(\w+)' "$APPLETS_H" 2>/dev/null | \
    sed 's/APPLET_NOFORK(\s*//' | \
    while read -r name; do
        # busybox main functions are named <name>_main
        # With bb_namespace.h, they get the bb_ prefix if they collide.
        # The actual symbol name after namespace prefixing is handled
        # at compile time, so we use the original name here.
        echo "BUSYQ_BB_APPLET(\"$name\", ${name}_main, BUSYQ_APPLET_NOFORK)"
    done >> "$OUTPUT"

# Extract APPLET_NOEXEC entries
grep -oP 'APPLET_NOEXEC\(\s*(\w+)' "$APPLETS_H" 2>/dev/null | \
    sed 's/APPLET_NOEXEC(\s*//' | \
    while read -r name; do
        echo "BUSYQ_BB_APPLET(\"$name\", ${name}_main, BUSYQ_APPLET_NOEXEC)"
    done >> "$OUTPUT"

# Extract regular APPLET entries (not NOFORK, NOEXEC, or ODDNAME)
grep -oP 'APPLET\(\s*(\w+)' "$APPLETS_H" 2>/dev/null | \
    grep -v 'APPLET_NOFORK\|APPLET_NOEXEC\|APPLET_ODDNAME\|APPLET_SCRIPTED' | \
    sed 's/APPLET(\s*//' | \
    while read -r name; do
        echo "BUSYQ_BB_APPLET(\"$name\", ${name}_main, 0)"
    done >> "$OUTPUT"

# Extract APPLET_ODDNAME entries (name differs from main func)
grep -oP 'APPLET_ODDNAME\(\s*(\w+)\s*,\s*(\w+)' "$APPLETS_H" 2>/dev/null | \
    sed 's/APPLET_ODDNAME(\s*//' | \
    while IFS=',' read -r name func; do
        name=$(echo "$name" | tr -d ' ')
        func=$(echo "$func" | tr -d ' ')
        echo "BUSYQ_BB_APPLET(\"$name\", ${func}_main, 0)"
    done >> "$OUTPUT"

echo "/* End of generated applet table */" >> "$OUTPUT"
echo "Generated $(grep -c BUSYQ_BB_APPLET "$OUTPUT") applet entries in $OUTPUT"
